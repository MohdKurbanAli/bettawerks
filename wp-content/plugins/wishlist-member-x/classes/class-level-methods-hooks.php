<?php
/**
 * Level Methods Hooks
 *
 * @package WishListMember
 */

namespace WishListMember;

/**
 * Level Methods Hooks trait
 */
trait Level_Methods_Hooks {
	/**
	 * Cron to trigger the expire/unexpire actions.
	 *
	 * @global \wpdb $wpdb
	 */
	public function trigger_level_expiration_hooks() {
		global $wpdb;
		$wlmdb = &$wpdb;

		$levels = $this->get_option( 'wpm_levels' );
		foreach ( $levels as $level_id => $level ) {
			$where_date = '';
			switch ( wlm_arrval( $level, 'expire_option' ) ) {
				case '1': // fixed term.
					/**
					 * Fixed term calendar period.
					 *
					 * @var string
					 */
					$calendar = strtoupper( wlm_arrval( $level, 'calendar' ) );
					if ( ! in_array( $calendar, array( 'DAYS', 'WEEKS', 'MONTHS', 'YEARS' ), true ) ) {
						$calendar = 'DAYS';
					}

					/**
					 * Date to be used in WHERE portion of SQL query for "fixed term" expiration
					 *
					 * @var string
					 */
					$where_date = sprintf(
						'"%s" >= date_add( rd.option_value, interval %d %s )',
						wlm_date( 'Y-m-d H:i:s' ),
						esc_sql( wlm_arrval( $level, 'expire' ) ),
						esc_sql( preg_replace( '/[S]$/', '', $calendar ) )
					);
					// continue to on date...
				case '2': // on date.
					if ( empty( $where_date ) ) {
						/**
						 * Date to be used in WHERE portion of SQL query for "on date" expiration
						 *
						 * @var string
						 */
						$where_date = sprintf(
							'"%s" >= "%s"', // always true.
							wlm_date( 'Y-m-d H:i:s' ),
							wlm_date( 'Y-m-d H:i:s.u', strtotime( wlm_trim( wlm_arrval( $level, 'expire_date' ) ) . ' ' . wlm_timezone_string() ) )
						);
					}

					/**
					 * Date to set our "expired" option to.
					 *
					 * This is generated by using the original $where_date and replacing
					 * everything from the start upto the ">=" with an empty string.
					 *
					 * @var string
					 */
					$set_date = preg_replace( '/^.+?>=/', '', $where_date );

					/**
					 * INSERT portion of SQL query
					 *
					 * @var string
					 */
					$query_insert = 'insert into %2$s ( userlevel_id, option_name, option_value ) select rd.userlevel_id, "expired", %4$s';

					/**
					 * SELECT portion of SQL query
					 *
					 * @var string
					 */
					$query_select = 'select ul.user_id';

					/**
					 * FROM portion of SQL query
					 *
					 * @var string
					 */
					$query_from = '`%1$s` as ul inner join `%2$s` as rd on ul.ID = rd.userlevel_id and ul.level_id = "%5$s" and rd.option_name = "registration_date" left join `%2$s` as exp on rd.userlevel_id = exp.userlevel_id and exp.option_name = "expired"';

					/**
					 * WHERE portion of SQL query.
					 *
					 * @var string
					 */
					$query_where = '%3$s and exp.ID is null';

					/**
					 * SELECT query template
					 *
					 * @var string
					 */
					$select_query_template = $query_select . ' from ' . $query_from . ' where ' . $query_where;

					/**
					 * INSERT query template
					 *
					 * @var string
					 */
					$insert_query_template = $query_insert . ' from ' . $query_from . ' where ' . $query_where;

					/**
					 * Query template replacements.
					 *
					 * @var array
					 */
					$replacements = array(
						$this->table_names->userlevels, // %1$s - wlm_userlevels table.
						$this->table_names->userlevel_options, // %2$s - wlm_userlevel_options table.
						$where_date, // %3$s - date for WHERE query.
						$set_date, // %4$s - date to be used when inserting expired status.
						esc_sql( $level_id ), // %5$s - membership level id.
					);

					/**
					 * Full SELECT query to select memberships that are to be expired.
					 *
					 * @var string
					 */
					$select_query = sprintf( $select_query_template, ...array_values( $replacements ) );

					/**
					 * Full INSERT query to expire memberships.
					 *
					 * @var string
					 */
					$insert_query = sprintf( $insert_query_template, ...array_values( $replacements ) );

					// get user ids to trigger for.
					$user_ids = $wlmdb->get_col( $select_query ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared

					if ( $user_ids ) {
						// mark levels as expired.
						$wlmdb->query( $insert_query ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared

						// run expire action for users that are to be expired for the current level.
						$this->do_expiration_action( true, $user_ids, $level_id );
					}

					/*
					 * Now we need to unexpire levels that are marked as expired but should not be.
					 * This happens when changed are made to the level expiration settings or a
					 * member's registration date.
					 */

					/**
					 * Full SELECT query to select memberhips that are to be unexpired
					 *
					 * This is generated by using the original $select_query and replacing the following:
					 * - ">=" with "<"
					 * - "and exp.ID is null" with ""
					 * - "left join" with "inner join"
					 *
					 * @var string
					 */
					$unexpire_select_query = str_replace( array( '>=', 'and exp.ID is null', 'left join' ), array( '<', '', 'inner join' ), $select_query );

					/**
					 * Full DELETE query to unexpire memberships
					 *
					 * This is generated by using the original $unexpire_select_query and replacing
					 * the value of $query_select with "delete exp"
					 *
					 * @var string
					 */
					$unexpire_delete_query = str_replace( $query_select, 'delete exp', $unexpire_select_query );

					// get users to trigger for.
					$user_ids = $wlmdb->get_col( $unexpire_select_query ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared

					if ( $user_ids ) {
						// mark levels as unexpired.
						$wlmdb->query( $unexpire_delete_query ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared

						// run unexpire action for users that are to be unexpired for the current level.
						$this->do_expiration_action( false, $user_ids, $level_id );
					}

					break;
				default: // no expiration. unexpire levels that are marked as expired for the current level.
					$query_from = sprintf(
						'from `%1$s` as ul join `%2$s` as ulo on ul.id=ulo.userlevel_id and ul.level_id="%3$s" and ulo.option_name="%4$s"',
						$this->table_names->userlevels,
						$this->table_names->userlevel_options,
						esc_sql( $level_id ),
						'expired'
					);

					// get user ids to trigger for.
					$user_ids = $wlmdb->get_col( 'select ul.user_id ' . $query_from ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared

					if ( $user_ids ) {
						// mark levels as unexpired.
						$wlmdb->query( 'delete ulo ' . $query_from ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared

						// run unexpire action for users that are to be unexpired for the current level.
						$this->do_expiration_action( false, $user_ids, $level_id );
					}
			}
		}
	}

	/**
	 * Called by wishlistmember_update_option_wpm_levels
	 * Called by wishlistmember_add_option_wpm_levels
	 * Called by wishlistmember_delete_option_wpm_levels
	 *
	 * @param  mixed $new_value  New levels.
	 * @param  mixed $old_value  Old levels.
	 */
	public function trigger_level_save_actions( $new_value = array(), $old_value = array() ) {
		// all levels were deleted.
		if ( 'wishlistmember_delete_option_wpm_levels' === current_action() ) {
			/**
			 * Fires when the wpm_levels option itself is deleted.
			 *
			 * @param string $level_id Always set to a value of "all".
			 * @param array  $data     Empty array.
			 */
			do_action( 'wishlistmember_level_deleted', 'all', array() );
			return;
		}

		if ( ! is_array( $new_value ) ) {
			$new_value = array();
		}
		if ( ! is_array( $old_value ) ) {
			$old_value = array();
		}

		$old_value_keys = array_keys( $old_value );
		$new_value_keys = array_keys( $new_value );

		$deleted_levels = array_unique( array_diff( $old_value_keys, $new_value_keys ) );
		$created_levels = array_unique( array_diff( $new_value_keys, $old_value_keys ) );

		foreach ( $deleted_levels as $level_id ) {
			if ( empty( $level_id ) ) {
				continue;
			}
			/**
			 * Fires when a level is deleted.
			 *
			 * @param string $level_id Level ID.
			 * @param array  $data     Old Level Data.
			 */
			do_action( 'wishlistmember_level_deleted', $level_id, $old_value[ $level_id ] );
		}

		foreach ( $created_levels as $level_id ) {
			if ( empty( $level_id ) ) {
				continue;
			}
			/**
			 * Fires when a level is created.
			 *
			 * @param string $level_id Level ID.
			 * @param array  $data     Level Data.
			 */
			do_action( 'wishlistmember_level_created', $level_id, $new_value[ $level_id ] );
		}
	}

	/**
	 * Trigger the expire/unexpire actions.
	 *
	 * @param  boolean      $expired  True to expire, False to unexpire.
	 * @param  array        $user_ids Array of User IDs.
	 * @param  string|array $levels   A single Membership Level ID or an array of the same.
	 */
	private function do_expiration_action( $expired, $user_ids, $levels ) {
		/**
		 * Action to run
		 *
		 * @var string
		 */
		$action = $expired ? 'wishlistmember_expire_user_levels' : 'wishlistmember_unexpire_user_levels';

		foreach ( (array) $user_ids as $user_id ) {
			/**
			* This action runs when a user's level expires
			*
			* @param int    $user_id  User ID.
			* @param array  $level_id Level ID.
			*/
			do_action( $action, $user_id, (array) $levels );
		}
	}
}

// register hooks.
add_action(
	'wishlistmember_register_hooks',
	function( $wlm ) {
		add_action(
			'init',
			function() {
				// Schedule per-minute cron to process level expiration actions.
				if ( ! wp_next_scheduled( 'wishlistmember_run_level_expiration_actions' ) ) {
					wp_schedule_event( time(), 'wlm_minute', 'wishlistmember_run_level_expiration_actions' );
				}
			}
		);
		add_action( 'wishlistmember_run_level_expiration_actions', array( $wlm, 'trigger_level_expiration_hooks' ) );

		// Run actions for when a level is created or deleted.
		add_action( 'wishlistmember_update_option_wpm_levels', array( $wlm, 'trigger_level_save_actions' ), 10, 2 );
		add_action( 'wishlistmember_add_option_wpm_levels', array( $wlm, 'trigger_level_save_actions' ) );
		add_action( 'wishlistmember_delete_option_wpm_levels', array( $wlm, 'trigger_level_save_actions' ) );
	}
);
